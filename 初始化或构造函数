一、构造函数
和OC中的初始化不一样，swift的初始化函数没有return；
所有的非可选存储属性都必须在初始化完成后完成赋值。
一般来说，如果每次的初始化值都是相同的，比较推荐在定义的时候就赋值，不建议在构造函数中赋值

二、默认构造器

三、构造器代理
在一个构造函数中调用另一个构造函数，用来简化逻辑和简化代码。
1、值类型的构造器代理
因为值类型的不支持继承，所以其构造器调用比较简单，只是自己内部的调用；
且构造器之间的调用只能在构造函数中使用
struct StruConstructor01{
    init() {

    }
    init(name: String){
        self.init();
    }
    func testInitFunc(){
//        self.init();// error 只能在构造器中调用
    }
}


2、引用类型的构造器代理（指定构造器和便利构造器（convenience），值类型的没有便利构造器）
因为引用类型可以继承，所以其构造器代理相对较复杂，需要遵守一定的规定。
指定构造器是一个类中的基础的构造器，一个指定构造器将初始化类中提供的所有属性，并根据父类链往上调用父类的构造器来实现父类的初始化。
便利构造器是次要的、辅助性的构造器，在同一个类中，便利构造器可以调用自己的指定构造器来初始化一些基础数据，你也可以定义便利构造器来创建一个特殊用途或特定输入值的实例
应该在需要的时候再定义便利构造器

* 每个类都必须拥有一个指定构造器。通常情况下，许多类通过继承父类的指定构造器来满足这个条件；

构造器调用规则：（指定构造器必须向上代理、便利构造器必须横向代理）
1、指定构造器必须调用其直接父类的指定构造器
2、便利构造器必须调用同类中的其他指定构造器
3、便利构造器必须导致一个指定构造器被调用

四、两段式构造过程（只有在第一部分完成之后，该类才能被使用）
swift中类的构造过程分为两部分：
第一部分：每个存储型属性被引入它们的类指定一个初始值。当每个存 储型属性的初始值被确定后，第二阶段开始；
第二阶段：它给每个类一次机会，在新实例准备使用之前进一步定制它们的存 储型属性。

编译器通过四种有效的安全检查，来保证这两段式构造过程：
第一种：在向上代理前，必须保证本类中的所有属性都被初始化了（因为一个类的占用空间只有在初始化完成后才能知道）
第二种：在使用父类的属性之前，必须先完成向上代理，如果不这么做，其父类的属性有可能会被其构造器重新修改
第三种：便利构造器必须在使用属性之前，必须首先完成横向代理，否则，其修改的新值有可能会被指定构造器修改了
第四种：构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用 self 作为一个值。

五、构造器的继承和重写
swift中，子类默认是不会继承父类的构造器，只会在特定的安全和合适的情况下被继承；
如果子类的指定构造器和父类的指定构造器想通了，则必须添加override，以标记为重写；
如果子类的指定构造器和父类的便利构造器相同了，则不需要override（根据构造器调用规则即可知道原因）

六、构造器自动继承
假设当前子类的所有非可选属性都被设置了默认值，则遵循以下两条：
第一条：如果当前子类没有定义任何指定构造器，则它会默认继承父类的指定构造器
第二条：如果当前子类重写了所有的父类的指定构造器（包括父类的指定构造器被子类继承重写为便利构造器也算），则默认继承了父类的便利构造器

七、可失败构造器
在init后面添加一个问号？，然后在函数中return nil；
场景：当在初始化的时候有参数不满足要求的时候即可返回nil，此时的构造器就必须是可失败的；
父类的可失败构造器在子类中可以被重写为不可失败的（如指定构造器或者便利构造器）

八、不可失败构造器
在init后面添加感叹号！即可

九、必须构造器
则每个子类都必须实现，且子类不能把require丢失
class SomeClass {
    required init() {
        // initializer implementation goes here
    }
}
class SomeSubclass: SomeClass {
    required init() {
        // subclass implementation of the required initializer goes here
    }
}



